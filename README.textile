h1. Dochi

h2. A Concatenative Programming Language

Dochi is strongly influenced by Factor, Lua and Clojure. Its design goal is to be lightweight and embeddable, similar to Lua. Its base data structures will be immutable, like Clojure.

h2. Syntax

* Code is a list of words, like Forth/Factor
* They operate on a stack
* Lexical bindings can be introduced at any point:
** Results in 4: @1 (a) a 2 + a +@
** Results in 11: @2 3 4 (a b c) a a + b + c +@
* Top level definitions use the 'def' keyword: @def square (a) a a *@
* Keywords: @:hello@
* Lists: @{1 2 3 4 "hello" "world"}@
* Tables: @#{:a 1 :b 2 :c 3}@
* Code quotations: @number? ["yes" write] ["no" write] if@

h2. Standard Library

h3. Interpreter-only

* @object .@ Pretty print object.
* @string write@ Print string.
* @clear@ Clear stack.
* @.s@ Print stack.
* @.e@ Print current environment.
* @.v@ Print current captured vars.

h3. Tables

* @<table>@ Create an empty table.
* @table value key <<@ Add (key, value) pair to table.
* @table key >>@ Lookup key in table.

h3. Lists

* @a b ;@ Cons a and b.
* @list head@ Head of list.
* @list tail@ Tail of list.

h3. Misc

* @+ - * / < > <= >=@ Binary operations on two numbers.
* @=@ General equality.
* @bool true-block false-block if@ Execute true-block if bool is true, else false-block.

h2. Internals

* Core.hs - Standard library implementation.
* IMC.hs - Immediate code data structures.
* Compile.hs - Translation from AST to immediate code. Resolution of words.
* Interpreter.hs - Haskell interpretation of immediate code. Uses @ChiState@ for state.
* Parse.hs - Parsing to AST, list of modules. Returns @Interactive@ type, or @Prog@, which is a list of @ChiModuleAST@.

* core.chi - More standard library written in Dochi.
* test.chi - Basic tests.

h3. Embedding in Haskell Code

* @Parse.dochiParseFile@ Turns a string of code into a @[ChiModuleAST]@.
* @Interpreter.emptyState@ an empty interpreter state.
* @Interpreter.injectAST@ compiles and injects a list of @ChiModuleAST@s into the interpreter state.
* @Interpreter.injectLib@ injects a Haskell @ChiModule@ into the interpreter state.
* @Interpreter.runWord@ runs a word in the given interpreter state.
* @Interpreter.runDochi@ runs a string of code in the given interpreter state.
* @Util.runFiles@ takes a list of filenames, parses and compiles them, and runs 'main'
* @Util.runFilesWithState@ does the same with an initial state.
