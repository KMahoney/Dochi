
module test

#import blah de blah ;
#export rah de rah ;
#private de re de ;


# simple object orientation

def <square> (size) T{:class :square} size :size <<
def <circle> (dia) T{:class :circle} dia :dia <<

def method-call (obj m) m obj :class >> >> obj swap call

def area T{

    :square [:size >> square]
    :circle [:dia >> 3 * square]

    } method-call


def factorial (n) n 1 <= [1] [n 1 - factorial n *] if

def run-test call ["."] ["X"] if write


module main

def main
    L{

    # simple tests

    [t]
    [f not]
    [t t and]
    [t f and not]
    [f t and not]
    [t t or]
    [t f or]
    [f t or]
    [f f or not]

    [1 1 + 2 =]
    [1 2 <]
    [2 1 >]
    ["test" dup =]
    [2 1 swap swap >]
    [5 factorial 120 =]


    # object/table tests

    [5 <circle> area 225 =]
    [5 <square> area 25 =]

    # combinator test

    [1 [5 +] [4 +] bi >]
    [1 [[1 +] [2 +] bi] [3 +] bi + + 9 =]

    # list test

    [0 L{1 2 3} [+] each 6 =]
    [f 3 ; 2 ; 1 ; L{1 2 3} =]
    [1 2 3 3 to-list L{1 2 3} =]

    [L{1 2 3} 2 remove L{1 3} =]
    [L{1 2 3 4} [2 <=] remove-if L{3 4} =]
    [L{1 2 3 4} [2 <=] filter L{1 2} =]

    } [run-test] each

